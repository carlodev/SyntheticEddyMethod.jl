var documenterSearchIndex = {"docs":
[{"location":"usage/#SEM-(Synthetic-Eddy-Method)-in-Julia","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"","category":"section"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"<!– | Documentation | |:–––––– | | (Image: )|  –>","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Inflow generation method by using Synthetic Eddy Method (SEM). At first, this method is developed by Jarrin (10.1016/j.ijheatfluidflow.2006.02.006) with a basic idea that turbulence is a superposition of coherent structures called eddies. ","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"The SEM assumes that the flow is comprised of randomly distributed turbulent spots, each of which is represented by a three-dimensional shape function that has a compact support and satisfies proper normalization conditions. These spots are then transported through an inlet plane using Taylor's frozen turbulence hypothesis, with a reference velocity. The resulting inflow turbulence is then reconstructed using a method proposed by researchers to recover the desired statistical properties and account for inhomogeneity and anisotropy. The choice of the shape function is crucial in the SEM as it directly affects the two-point autocorrelation function and the power spectrum of the synthetic turbulence.","category":"page"},{"location":"usage/#How-to-use","page":"SEM (Synthetic Eddy Method) in Julia","title":"How to use","text":"","category":"section"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"At first, the user defines the dimension and resolution of the virtual box where the eddies are going to be generated as well as the dimension of the eddies (σ). A common choice is σ = 2Δz or σ = Δz, where Δz is the mesh resolution in the z direction.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"using SyntetichEddyMethod\r\n\r\nσ = 0.1\r\nb = 5.0\r\na = 0.0\r\n\r\ny = collect(a:0.1:b)\r\nz = collect(a:0.1:b)\r\n","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Notice: only the first and last value of ´y´ and ´z´ are used to create the VirtualBox.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Then you create the VirtualBox structure that has embedded all the information about the virtual box where the eddy are generated. The number of eddy is automatically computed in order to guarantee an homogeneous fill. You can manually override the value (Vboxinfo.N).","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"\r\nVboxinfo = VirtualBox(y,z,σ)\r\n\r\nN = Vboxinfo.N #you can override it ","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"You can specify also the x direction dimensions, a different shape funcion and different ´σ´ in the three different directions.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"using SyntetichEddyMethod\r\n\r\nσ = 0.1\r\nb = 5.0\r\na = 0.0\r\na = collect(-1:0.1:1)\r\ny = collect(a:0.1:b)\r\nz = collect(a:0.1:b)\r\nσx = 0.1\r\nσy = 0.05\r\nσz = 0.07\r\nσ = [σx,σy,σz]\r\nVboxinfo = VirtualBox(x,y,z,σ; shape_fun = step_fun)","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Then, eddies are initialize in the virtualbox with random values of position and intensity. You have to specify the time-step, dt. Then the Reynolds stress tensor. Here homegeneous and isotropic turbulence is considered, so R_ij = 0 i=j R_ij = 0 i=j, and the terms are computed from the turbulence intensity (TI). Then the Matrix A is created using the cholesky_decomposition function.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Eddies = initialize_eddies(N, σ, Vboxinfo)\r\nt = 0\r\ndt = 0.001\r\nU₀ = 1.0\r\nTI = 0.6 #turbulence intensity\r\n\r\n#Isotropic turbulence\r\nu_p = (U₀ * TI)^2\r\n\r\nRe_stress = [u_p 0.0 0.0; \r\n            0.0 u_p 0.0;\r\n            0.0 0.0 u_p]\r\n\r\nA = cholesky_decomposition(Re_stress)\r\n","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"You have to create a Vector{Vector{Float64}} of points where you want to evaluate the speed.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"vector_points = create_vector_points(x, y, z)","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"You can create evaluate the speed in just one point (useful for monitoring how the velocity varies in time and creating the spectra)","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"vector_points = [[0.0, 1.0, 2.5]]","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Compute the velocity fluctuation and then is 'corrected' using the matrix A. The velocity and the turbulent kinetic energy are then computed.","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"u_fluct = compute_uᵢₚ(vector_points, dt, Eddies, U₀, Vboxinfo)[1]\r\nU, Ek =  compute_U_k(u_fluct, A, U₀)","category":"page"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"From here you can generate the spectra of your signal. For more detail look at files in test/","category":"page"},{"location":"usage/#Tests","page":"SEM (Synthetic Eddy Method) in Julia","title":"Tests","text":"","category":"section"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"Look in folder /test for the in-deep results of testing","category":"page"},{"location":"usage/#Acknowledgement","page":"SEM (Synthetic Eddy Method) in Julia","title":"Acknowledgement","text":"","category":"section"},{"location":"usage/","page":"SEM (Synthetic Eddy Method) in Julia","title":"SEM (Synthetic Eddy Method) in Julia","text":"nomenclature: 10.1016/j.ijheatfluidflow.2006.02.006\nshape function definition thanks to the Fortran 90 code https://github.com/blackcata/SEM.git and the related paper 10.1016/j.ijheatmasstransfer.2019.02.061\nhttps://nheri-simcenter.github.io/WE-UQ-Documentation/common/technical_manual/desktop/WEUQ/TinF.html for detailed description of the procedure","category":"page"},{"location":"exploring/#Exploring-the-package","page":"Exploring the package","title":"Exploring the package","text":"","category":"section"},{"location":"exploring/#Visualize-the-centre-of-the-eddies","page":"Exploring the package","title":"Visualize the centre of the eddies","text":"","category":"section"},{"location":"exploring/","page":"Exploring the package","title":"Exploring the package","text":"using SyntheticEddyMethod\r\nusing Plots\r\nσ = 0.1\r\nb = 5.0\r\na = 0.0\r\nx = collect(-0.1:0.1:0.1)\r\ny = collect(a:0.1:b)\r\nz = collect(a:0.1:b)\r\n\r\n\r\nVboxinfo = VirtualBox(x, y,z, σ)\r\nVboxinfo.N = 100\r\ndt = 0.01\r\n\r\nU₀ = 1.0 #Convective Velocity\r\nTI = 0.2 #turbulence intensity\r\nA, Eddies = initialize_eddies(U₀, TI, Vboxinfo)\r\n\r\nPlots.scatter([Eddies[1].xᵢ[1]], [Eddies[1].xᵢ[2]], [Eddies[1].xᵢ[3]], legend=false, ms=2, color=:black)\r\nfor i = 2:1:length(Eddies)-1\r\n    Plots.scatter!([Eddies[i].xᵢ[1]], [Eddies[i].xᵢ[2]] , [Eddies[i].xᵢ[3]],  legend=false,  ms=2, color=:black)\r\n\r\nend\r\nPlots.scatter!([Eddies[end].xᵢ[1]], [Eddies[end].xᵢ[2]] , [Eddies[end].xᵢ[3]],   legend=false,  ms=2, color=:black)\r\n\r\n","category":"page"},{"location":"exploring/#Visualize-isosurface-velocity","page":"Exploring the package","title":"Visualize isosurface velocity","text":"","category":"section"},{"location":"exploring/","page":"Exploring the package","title":"Exploring the package","text":"using PlotlyJS\r\nX, Y, Z = mgrid(x, y, z)\r\nvector_points = create_vector_points(x, y, z)\r\n\r\nvalue = compute_uᵢₚ(vector_points, dt, Eddies, U₀, Vboxinfo)[1]\r\n\r\niso_surfaces = isosurface(\r\n    x=X[:],\r\n    y=Y[:],\r\n    z=Z[:],\r\n    value=value[:,1],\r\n    isomin=0.1,\r\n    isomax=1,\r\n    surface_count=3,\r\n    opacity=0.5,\r\n    caps=attr(x_show=false, y_show=false)\r\n)\r\n\r\nlayout=Layout(yaxis=attr(scaleanchor=\"x\", scaleratio=1), zaxis=attr(scaleanchor=\"x\", scaleratio=1))\r\nio = PlotlyJS.plot(iso_surfaces, Layout(yaxis=attr(scaleanchor=\"x\", scaleratio=1)))","category":"page"},{"location":"#SyntheticEddyMethod.jl","page":"Introduction","title":"SyntheticEddyMethod.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Package for synthetic eddy generation","category":"page"},{"location":"#Package-Features","page":"Introduction","title":"Package Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Create coeherent eddies in 3D domain","category":"page"},{"location":"#Function-Documentation","page":"Introduction","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SEM_EDDY\r\nVirtualBox\r\nconvect_eddy\r\ncreate_vector_points\r\ncompute_U_k\r\ninitialize_eddies\r\ncompute_uᵢₚ","category":"page"},{"location":"#SyntheticEddyMethod.SEM_EDDY","page":"Introduction","title":"SyntheticEddyMethod.SEM_EDDY","text":"Structure with the property of a single eddy\n\n\n\n\n\n","category":"type"},{"location":"#SyntheticEddyMethod.VirtualBox","page":"Introduction","title":"SyntheticEddyMethod.VirtualBox","text":"Virtual Volume box where the eddies are created\n\n\n\n\n\n","category":"type"},{"location":"#SyntheticEddyMethod.convect_eddy","page":"Introduction","title":"SyntheticEddyMethod.convect_eddy","text":"Compute the new position of all the Eddies. We consider only the convective velocity along x axis. If outside the Virtual Box, a new eddy is randomly generated inside the Virtual Box\n\n\n\n\n\n","category":"function"},{"location":"#SyntheticEddyMethod.create_vector_points","page":"Introduction","title":"SyntheticEddyMethod.create_vector_points","text":"Create a vector of points\n\n\n\n\n\n","category":"function"},{"location":"#SyntheticEddyMethod.compute_U_k","page":"Introduction","title":"SyntheticEddyMethod.compute_U_k","text":"Compute the acutual velocity and the turbulent kinetic energy. The convective velocity is just in the x direction\n\n\n\n\n\n","category":"function"},{"location":"#SyntheticEddyMethod.initialize_eddies","page":"Introduction","title":"SyntheticEddyMethod.initialize_eddies","text":"Initialize Eddy position and intensity\n\n\n\n\n\n","category":"function"},{"location":"#SyntheticEddyMethod.compute_uᵢₚ","page":"Introduction","title":"SyntheticEddyMethod.compute_uᵢₚ","text":"The velocity in the 3 directions is computed in each point provided in x\n\n\n\n\n\n","category":"function"}]
}
